# -*- coding: utf-8 -*-
"""Classiq adaptation for VQLS with QAOA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F0WKqYD2IPIV_RZUsoTtG_78ukpkGuoi
"""

import numpy as np
from scipy.optimize import minimize
from classiq import *
from classiq.execution import ExecutionSession, ClassiqBackendPreferences, ExecutionPreferences
from classiq.synthesis import set_execution_preferences


def compute_normalization_params(n: int, J: float, kappa: float):
    """Compute ζ and η to ensure eigenvalue bounds: smallest = 1/κ, largest = 1."""
    max_unnorm = n + J * (n - 1)
    min_unnorm = -(n + J * (n - 1))
    zeta = (max_unnorm - min_unnorm) * kappa / (kappa - 1)
    eta = -min_unnorm - zeta / kappa
    return zeta, eta


def form_matrix_from_string(pauli_string):
    """Generate matrix from a Pauli string."""
    pauli_dict = {
        "I": np.eye(2),
        "X": np.array([[0, 1], [1, 0]]),
        "Y": np.array([[0, -1j], [1j, 0]]),
        "Z": np.array([[1, 0], [0, -1]]),
        "H": np.array([[1, 1], [1, -1]]) / np.sqrt(2),
    }
    result = pauli_dict[pauli_string[0]]
    for char in pauli_string[1:]:
        result = np.kron(result, pauli_dict[char])
    return result


def prepare_lcu_matrix(pauli_terms):
    """Prepare LCU representation of the matrix."""
    c = np.array([term[1] for term in pauli_terms], dtype=float)  # Ensure float type
    c /= np.sum(c)  # Normalize coefficients to form a probability distribution

    @qfunc
    def prepare_c(ancillary_qubits: QArray[QBit]):
        # Explicitly set target and error bound, ensuring compatibility
        state = np.sqrt(c).tolist()  # Prepare amplitude values as a list
        inplace_prepare_state(state, bound=0.0, target=ancillary_qubits)

    return prepare_c


class VQLSSolverClassiq:
    def __init__(self, n_qubits, n_layers, kappa=10, epsilon=0.01):
        self.n_qubits = n_qubits
        self.n_layers = n_layers
        self.kappa = kappa
        self.epsilon = epsilon
        self.training_history = {"global": []}
        self.qprog = None
        self.session = None
        self.ansatz_param_count = self.n_layers * self.n_qubits * 2
        self.ansatz_var_name = "system_qubits"
        self.aux_var_name = "ancillary_qubits"
        self.intermediate = {}

    def create_ansatz(self):
        """Define a QAOA-like ansatz."""
        @qfunc
        def ansatz(params: CArray[CReal], system_qubits: QArray[QBit]):
            param_idx = 0
            for _ in range(self.n_layers):
                repeat(
                    count=self.n_qubits,
                    iteration=lambda i: RZ(params[param_idx + i], system_qubits[i]),
                )
                param_idx += self.n_qubits
                repeat(
                    count=self.n_qubits,
                    iteration=lambda i: RX(params[param_idx + i], system_qubits[i]),
                )
                param_idx += self.n_qubits
                repeat(
                    count=self.n_qubits - 1,
                    iteration=lambda i: CZ(system_qubits[i], system_qubits[i + 1]),
                )
            return system_qubits

        return ansatz

    def get_cond_prop(self, res):
        """Calculate conditional probability."""
        aux_prob_0 = sum(s.shots for s in res if s.state[self.aux_var_name] == 0)
        all_prob_0 = sum(
            s.shots
            for s in res
            if s.state[self.aux_var_name] == 0 and s.state[self.ansatz_var_name] == 0
        )
        return all_prob_0 / aux_prob_0 if aux_prob_0 > 0 else 0

    def my_cost(self, params):
        results = self.session.sample(params)
        parsed_counts = results.parsed_counts_of_outputs([self.ansatz_var_name, self.aux_var_name])
        overlap_squared = self.get_cond_prop(parsed_counts)  # Ensures overlap computation
        return 1 - overlap_squared

    def train(self, n_epochs=100):
        parameters = np.random.uniform(0, np.pi, self.ansatz_param_count)

        def cost_function(x):
            params = {"params_" + str(k): x[k] for k in range(self.ansatz_param_count)}
            cost = self.my_cost(params)
            self.intermediate[tuple(x)] = cost
            return cost

        for epoch in range(n_epochs):
            result = minimize(
                cost_function, parameters, method="COBYLA", options={"maxiter": 200}
            )
            parameters = result.x
            cost = result.fun
            self.training_history["global"].append(cost)
            print(f"Epoch {epoch + 1}/{n_epochs}: Global Cost = {cost:.4f}")
            if cost < (self.epsilon ** 2) / (self.kappa ** 2):
                print("Desired precision achieved; stopping early.")
                break

    def prepare_program(self, pauli_terms):
        """Prepare the quantum program."""
        ansatz = self.create_ansatz()
        prepare_c = prepare_lcu_matrix(pauli_terms)

        @qfunc
        def main(
            params: CArray[CReal, self.ansatz_param_count],
            system_qubits: Output[QArray[QBit]],
            ancillary_qubits: Output[QArray[QBit]],
        ):
            allocate(self.n_qubits, system_qubits)
            allocate(2, ancillary_qubits)
            apply_to_all(H, system_qubits)  # Prepare |b⟩ state
            prepare_c(ancillary_qubits)
            ansatz(params, system_qubits)

        backend_preferences = ClassiqBackendPreferences(backend_name="simulator_statevector")
        model = create_model(main)
        model = set_execution_preferences(
            model,
            execution_preferences=ExecutionPreferences(num_shots=1024, backend_preferences=backend_preferences),
        )
        self.qprog = synthesize(model)
        self.session = ExecutionSession(self.qprog)


def run_vqls():
    solver = VQLSSolverClassiq(n_qubits=3, n_layers=2, kappa=10, epsilon=0.01)
    pauli_terms = [("IIZ", 0.5), ("IZI", 0.25), ("ZZI", 0.25)]
    solver.prepare_program(pauli_terms)
    solver.train(n_epochs=50)


run_vqls()